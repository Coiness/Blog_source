---
title: 算法日记-8 LCR 164.破解闯关密码
date: 2024-09-23 16:11:06

tags:
- LeetCode
- Sort
- Medium
categories:
- LeetCode

---

[LeetCode指路](https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/description/) 难度：中等

闯关游戏需要破解一组密码，闯关组给出的有关密码的线索是：

- 一个拥有密码所有元素的非负整数数组 `password`
- 密码是 `password` 中所有元素拼接后得到的最小的一个数

请编写一个程序返回这个密码。

<!--more-->

#### 题解

##### 方法一：自定义排序

首先，要清楚这个问题要得到的目标是什么？判断的依据是什么？这个问题的本质是什么？

思考可以得到，这是一个拼接的问题，要得到一串最小的拼接字符串，本质是排序。

既然是排序，那么规则是什么？根据问题得，我们想要通过排序得到最小的字符串。那么排序规则就要做到使字符串最小。

理所当然，我们会先想到，小的排在前面，大的排在后面。然而样例告诉我们，当遇到30、34和3时，这个规则是行不通的。为什么行不通？因为我们要的是拼接的string，而不是int，两个根本就不是一回事！

那么我们就用string来，那怎么比较呢？这个规则是该怎么定呢?

我们用贪心来解答。先不要考虑三个或多个数字，比较嘛，就两个两个来。30和34谁排前面，就按计算的结果来，3034 < 3430 ，所以应该30排在前面，3和30谁排在前面 330 > 303。结果显而易见，排序规则也是如此。`x+y < y+x`字符串的拼接。

那么我们来梳理一下我们要做什么

首先将int数组转换为string数组

```cpp
std::vector<std::string> ans;
for(int num:password){
    ans.push_back(std::to_string(num));
}
```

然后创造排序规则

```cpp
bool compare(const string &a, const string &b){
    return a+b < b+a;
}
```

最后调用实现，并将答案转换为string输出就行了

```cpp
std::string ans_str;
for(std::string str:ans){
    ans_str += str;
}
```
