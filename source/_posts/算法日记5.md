---
title: 算法日记-5 238.除自身以外数组的乘积
date: 2024-09-18 14:58:11
categories:
- LeetCode
- Array
- Medium
tag:
- LeetCode
- Array
- Medium
---

[LeetCode指路](https://leetcode.cn/problems/product-of-array-except-self/description/) 难度：中等

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请 **不要使用除法**，且在 `O(n)` 时间复杂度内完成此题。

<!--more-->

#### 题解：

首先，该题最难的点在于不能使用除法，同时要求时间复杂度为O(n)。那么该怎么办呢？

##### 方法1：左右乘积列表

看着这道题，一开始会觉得难以下手，但是当我们想起之前在算法日记-3 724.寻找中心下标的时候，就会感到这两题是何等地相似。数组中的一个数将整个数组分为了三个区间，左边、右边和自己本身。

既然暴力算法已经被明确禁止了，那么结合之前的经验，我们可以知道，要想提高速度，就应该重复利用计算结果，同时找出三个区间之间的关系。

首先第一个想到的，是通过计算整个区间的乘积值，然后通过除法得出答案。然而除法是禁止的，所以pass掉。

第二个，结果 = 左区间乘积 * 右区间乘积。按照重复利用计算结果的思路，我们可以发现，当计算左区间时，n的左区间往往可以通过n-1的左区间和nums[n-1]相乘得到。按照这个思路，n的右区间可以通过 ~~n-1的右区间除以n得到~~ n+1的右区间和nums[n+1]相乘得到。

从这个角度看，左区间和右区间其实是对称的。那么，我们只需要从左往右计算各个节点的左区间乘积，将结果存储起来。然后再从右往左计算各个节点的右区间，将结果存储起来。最后两个数组相乘得到新的数组，新的数组就是应该返回的答案了。

``` cpp
int n = nums.size();
std::vector<int> beforSum(n,1);
std::vector<int> afterSum(n,1);

for(int i = 1; i < n; i++){
    beforSum[i] = beforSum[i-1] * nums[i-1];
    afterSum[n-i-1] = afterSum[n-i] * nums[n-i];
}

for(int i = 1; i < n; i++){
    beforeSum[i] *= afterSum[i];
}
return beforeSum;
```

##### 方法2：优化-O(1)空间复杂度

在方法一种，我们已经通过返回beforeSum来减少空间复杂度了，那么能不能在计算出beforeSum后，不再使用额外的数组空间来计算出答案呢？答案是肯定的。

``` cpp
int temp = 1;
for(int i = n-2; i > 0 ; i--){
    temp *= nums[i];
    beforSum[i-1] *= temp;   
}
```

##### 方法3：双指针

这又是一个空间复杂度为O(1)的方法。跟方法2不同的是，它在一个for循环里同时计算左右区间的值并存储到ans中

``` cpp
int templ = 1;
int tempr = 1;
std::vector<int> ans(10,1);

for(int i = 0; i < n; i++){
    ans[i] *= templ;
    ans[n-i-1] *= tempr;
    templ *= nums[i];
    tempr *= nums[n-i-1];
}
```
