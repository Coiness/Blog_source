---
title: 算法日记9
date: 2024-09-24 15:05:06
tags:
- LeetCode
- Sort
- Array
- Easy
categories:
- LeetCode
---

[LeetCode指路](https://leetcode.cn/problems/move-zeroes/description/) 难度：简单

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

冒泡、双指针、stable_partition、remove + fill

<!--more-->

#### 题解

应该算是比较经典的题目了。该题没什么难点，有很多方法可以解答。

##### 冒泡排序

经典，无需多言

##### 双指针

遍历覆盖。相当于只读取非0元素，并且覆盖前面的部分。当后面的指针遍历过后，前面的指针再将剩下的元素置零就完成了。

```cpp
int i = 0;
int j = 0;

for(;i < nums.size(); i++){
    if(nums[i] == 0){
    }
    else{
        nums[j] = nums[i];
        j++;
    }
}

while (i != j){
nums[j] = 0;
j++;
}
```

##### sort?

错误的做法，因为sort是非稳定排序，会改变数据的顺序。

##### stable_partitionr

`stable_partiton`是C++标准库中的一个算法，可以稳定地将数组分为两个部分。

```cpp
template< class BidirectionalIterator, class UnaryPredicate >
bool stable_partition( BidirectionalIterator first, BidirectionalIterator last,
                      UnaryPredicate p );

```

参数说明：

- first：分类的起点

- last：分类的终点

- UnaryPredicate p：单参数 谓词

---

返回bool类型的仿函数就是谓词。如果还看不明白，看看例子就懂了

###### 表达方式1：普通函数

```cpp
bool compare(const int &x, const int &y){
    return x > y;
}
```

看明白了吗？这是双参数谓词，很熟悉不是吗。

###### 表达方式2：Lambda函数

```cpp
[捕获列表](参数列表) -> 返回类型 {
    // 函数体
}


[x](int y) -> bool{
    return x > y;
}
```

###### 表达方式3：仿函数(函数对象)

```cpp
struct Compare{
    int x;

    Compare(int t): x(t){}
    
    bool operator()(int y) const{
    return x > y;
    }
}
```

---

其实总结一下，跟sort的第三个参数其实是很像的。那么我们也可以简单地得出使用stable_partition函数的代码。

```cpp
std::stable_partition(nums.beigin(),nums.end(),[](int x){
    x != 0;
})
```

这样，就可以将数据划分为两半，前部分是`x != 0`

stable_partition是如何实现的？

基准情况处理，递归划分，旋转合并，返回新的分隔点。

##### remove + fill

remove函数会移除数组中所有指定的元素，同时返回一个指向新的“结束”位置的迭代器

```cpp
auto it = std::remove(nums.begin(), nums.end(), 0);
std::fill(it, nums.end(), 0);
```
