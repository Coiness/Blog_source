---
title: 当 AI 重构 Coding
date: 2026-01-06 12:56:06
tags:
- AI
categories:
- 技术
---

看了几场 FEDAY 2025 演讲，心潮澎湃啊，写下这篇文章来作为26年的开篇。

<!--more-->

大家好啊，我是coiness，一名在大三在读的前端开发者。

上个月参加了字节的前端工程师训练营，学到了很多知识，最后也参与了项目答辩。

在项目答辩中，我印象最深的问题就是面试官最后问的，我对AI的理解。

当时我没怎么准备，只是简单讲讲我平时怎么用AI的，写项目的整体prompt进行更新啊，使用AI coding IDE 什么的。

答完后一下播就后悔了，因为感觉自己答得太浅了，得亏自己还是人工智能专业的呢哈哈。

后面回去后也是加急补课，在B站看到了很多的视频，有实操项目的，基建方面的AI组件库，也有构建一整套根据图片生成页面布局的系统的。

但是给我印象最深的，是up主 前端圈 上传的一系列演讲视频。他们举办了一个技术大会，作为前端开发者分享自己的经验和知识。

里面的演讲基本都是在讲AI，内容很丰富，也很有趣，我分享一下我觉得比较有意思的观点。

## AI的认知税

这是在演讲[AI 编程的"认知税"](https://mp.weixin.qq.com/s/JLHe9jovVi9O3OY6cCZ4Ug)中给出的一个现象，我觉得很有意思，下面是图片

![AI 编程的"认知税"](/images/AI-coding-tax.png)

为什么会出现这样的情况呢？对于0-3分和8-10分任务擅长的AI，为什么在4-7分上会进入探索地狱呢？

作者举了一个恰当的例子，并剖析了这个问题。

人类做出判断需要全面的信息，AI也是。但是人类和AI不同，人类可以我感觉，我认为，有可能，但是AI不行。

其实AI不是不行，AI是不知道，因为人类有五感、有经验、有隐形上下文，这些是AI不知道，但是我们又容易忽略，没告诉AI的。

更底层的，就是关于AI的思维了，AI的思考过程是一个逐渐收敛的过程，根据A得到B，根据B来得到C，最后才根据C得到D。一轮又一轮的收敛，延续旧轨迹而非生成新图示。

相比于人类，第一次 A -> B -> C -> D，第二次就 A -> D 了。

讲到底我认为也还是上下文的问题，人类的上下文是动态的，而大模型则在出厂的那一刻被静止了，除非提供上下文，否则下次见了，也还要走一次收敛的过程。

## Spec Coding vs Vibe Coding

Vibe Coding 相信大家早有耳闻了，而Spec Coding对于我来说则是第一次。

两种是完全不同的AI编程模式。
![Spec Coding vs Vibe Coding](/images/Spec-Coding-vs-Vibe-Coding.png)

Vibe Coding主要靠感觉，像一个艺术家一样，只要跟着灵感来，也不用管怎么画出来的，画就是了。Vibe Coding加速了创意的落地，也降低了普通人的创作门槛，很美好，不过存在问题，这样的代码往往也都是靠着感觉来的，感觉可不靠谱，尤其是与不靠谱的AI结合，更不用说了。

Spec Coding则主要靠规范，像一个工程师一样，把需求进行细致拆分，再进行规划，给出解决方案，列出任务清单，最后才进行编码。虽然token消耗会多一点，但是代码更加规范，可维护性也更高。不过与之对应的，对于一些重要的内容，需要人工进行确认和审核，确保质量，存在一定门槛。

对于我来说，其实我一直都期望的是Spec Coding，毕竟谁不想要可维护性高的代码呢哈哈。
而且我感觉我们前端也是算是比较注重工程化了，对于程序员来说Spec Coding可以说是众望所归。

如何实现Spec Coding也是个问题，演讲上没说,不过我很感兴趣，我放一篇我看到的文章，有空实践一下
[link](https://www.softwareseni.com/spec-driven-development-in-2025-the-complete-guide-to-using-ai-to-write-production-code/)

## 工具的演进与 CLI 的回归

AI Coding 的工具形态其实一直在变，而且变得非常有意思。我们可以从两个维度来观察：AI 的大脑（能力） 和 AI 的手脚（交互）。

大脑的进化：从工作流到 Skill

1.  Copilot 阶段：最早的大模型其实没有 Coding 能力，只能聊天。后来能写代码了，但只能补全一两行，这是“副驾驶”。
2.  Workflow 阶段：出现了 Function Calling，我们开始用工作流（Workflow）把 AI 串起来。但这就像是给 AI 画好了轨道，它只能按部就班地跑，很死板。
3.  Agent 阶段：为了让 AI 更灵活，我们引入了 Agent 和 Tools，让 AI 能够自主决策：“我现在需要查文档，还是需要运行代码？”
4.  Skill 阶段：Agent 的 Tools 太多太烧 Token 怎么办？Anthropic 提出了 Skill 的概念，相当于对工具进行“懒加载”，只在需要的时候才加载对应的技能，既省钱又聪明。

![工具的演进](/images/AI-Tools-Evolution.png)

在这个过程中，AI 的自主权越来越大，从“执行命令”变成了“解决问题”。

手脚的回归：为什么是 CLI？

而在交互工具层面，经历过 Chat 网页 -> IDE 插件 -> AI IDE (Cursor/Trae) 的华丽演变后，Qwen 团队却提出了一个看似“返璞归真”的方向：CLI (命令行界面)。

初听觉得是倒退，细想却是必然。

图形界面 (GUI) 是为人设计的，我们需要按钮、菜单、颜色来降低认知负担。但 AI 不需要这些，AI 的本质是文本处理引擎。

对于 AI 来说，CLI 才是最高效的“母语”接口，我也总结了几个原因：
- 摆脱臃肿：告别了沉重的 IDE，CLI 让 AI 能更轻量、自由地与本地系统底层进行交互，不再受限于编辑器的框框。
- 场景通用：CLI 天生适合云端和服务器环境，可以实现 7x24 小时不间断运行。这一点是依赖图形界面的 IDE 很难做到的。
- 模型适配：各家厂商推出的 CLI 工具都对自家模型进行了深度优化，适配程度最高，能发挥出模型的最大潜能。

这就解释了为什么“通用 > 垂直”。我们不需要一堆垂直领域的 AI 工具，我们需要的是一个能熟练操作 CLI 的通用 Agent。

## 结语：前端不止于前端

写到这里，我突然释怀了那次面试的尴尬。

当时我遗憾自己答得太浅，是因为我还在用“旧前端”的思维看 AI——把它当成一个补全代码的插件。

但现在的我明白，AI 正在重构我们 Coding 的方式。
- 它让我们从“写代码的人”变成了“设计上下文的人” (Context Engineer)。
- 它让我们从纠结语法细节 (Vibe Coding) 转向关注工程规范 (Spec Coding)。
- 它甚至通过 CLI，让我们有了操作整个系统的能力。

正如我在 about 页面写的那样：“AI 把前端从前端解放出来了，前端应该不止于前端。”

2026 年，作为一名新入行的开发者，我不焦虑了。因为我知道，属于我们的时代，才刚刚开始。

>后面的部分都是AI优化了的哈哈，包括工具演进和总结，太久没写有点无能了我说，不过观点都是我的，至少是我收集来的www，希望这篇文章对你有所帮助(图片都是从演讲里摘的，我也想用Banana。。。)

