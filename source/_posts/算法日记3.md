---
title: 算法日记-3 724.寻找数组的中心下标
date: 2024-09-17 16:24:11
categories:
- LeetCode
- Array
- Easy
tag:
- LeetCode
- Array
- Easy
---

[LeetCode指路](https://leetcode.cn/problems/find-pivot-index/) 难度：简单

给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。

<!--more-->

#### 题解

首先讲一下特殊情况

当数组里面只有一个元素时，左右都是空和，为0，此时可以直接返回1。

当数组里面的元素为2时，你可能会想，一边是空和，另一边是一个数组元素，这种情况一定不存在左右和相等的情况。然而并非如此，当数组元素为0时，两边就相等了。

另外，由于数组中可能出现负数，所以打算两边同时向中间推进找中心下标的想法是行不通的。

##### 方法1：暴力算法

遍历数组每个元素，遍历时，将其左边和与右边和进行计算。

时间复杂度为O(n<sup>2</sup>)

##### 方法2：暴力算法改良

仔细观察，我们可以发现，方法一的缺陷就是有部分数字算过了又再算了一次。

当我们算完第n位后，在算第n+1位时，其实并不用重新将第1位至第n位的左右和重新算一遍。只需要将原本的suml加上第n位，sumr减去第n+1位。

```cpp
int suml = 0;
int sumr = 0;

for(int i = 0;i < nums.size();i++){
    sumr += nums[i];
}


for(int i = 1;i < nums.size();i++){
    suml += nums[i-1];
    sumr -= nums[i];
    if(suml == sumr){
    return i;
}
}

return -1;
```

##### 方法3：前缀和

这个是LeetCode官方解法，跟方法2很像。

整个数组可以分为 总数组 中心位置 左 右

有等式 total = nums[i] + suml + sumr ;

在方法2中，suml == sumr 是判断的标准。

而在方法3中，利用了上面的等式，将sumr替换，判断标准变为

suml == total - nums[i] - suml  ;

```cpp

int suml = 0;

int total = 0;


for(int i = 0;i < nums.size();i++){
    total += nums[i];
}

for(int i = 1;i< nums.size();i++){
    suml += nums[i-1];
    if(2*suml + nums[i] == total){
    return i;
}
}

return -1;
```
