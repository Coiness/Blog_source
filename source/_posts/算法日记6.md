---
title: 算法日记-6 498.对角线遍历
date: 2024-09-19 11:25:06
tags:
- LeetCode
- Array
- Medium
categories:
- LeetCode
---

[LeetCode指路](https://leetcode.cn/problems/diagonal-traverse/) 难度：中等

给你一个大小为 `m x n` 的矩阵 `mat` ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。

<!--more-->

#### 题解

这题最大的麻烦就在于各种ifelse判断。

---

首先，线的走向只有两种，up和down。这是第一个分类点。

然后，当触碰到边界时，需要更改走向。

在触碰到边界时，有四条边界，每个边界的处理情况也不一样。

---

对于up，会碰到上边界和右边界

当触碰到上边界时，`y++`，`x`不变，也就是`右移`

当触碰到右边界时`x++`，`y`不变，也就是`下移`

这时就出现了一个问题，当触碰到的是右上角呢？此时如果`y++`，就会造成数组越界。

处理1：先判断上边界再判断右边界。在右边界中嵌套判断和处理 。//右移不处理会越界

处理2：先判断右边界再判断上边界。 //下移处理不会越界

上面用的都是 if 和 else if

对于down，这是对称的，不再赘述。

---

所以大体的框架已经出来了。代码如下：

```cpp
bool state = true;    // up 为 true，down 为 false
int n = mat.size();
int m = mat[0].size();
int x = 0;
int y = 0;
std::vector<int> ans;

for (int i = 0; i < n * m; i++) {
    ans.push_back(mat[x][y]);
    if (state) {
        // 触碰右边界
        if (y == m - 1) {
            x++;
            state = !state;
        }
        // 触碰上边界
        else if (x == 0) {
            y++;
            state = !state;
        }
        // 未触碰边界
        else {
            x--;
            y++;
        }
    } else {
        // 触碰下边界
        if (x == n - 1) {
            y++;
            state = !state;
        }
        // 触碰左边界
        else if (y == 0) {
            x++;
            state = !state;
        }
        // 未触碰边界
        else {
            x++;
            y--;
        }
    }
}
```
