---
title: 算法日记-7 48.旋转图像
date: 2024-09-19 11:54:33
tags:
- LeetCode
- Array
- Medium
categories:
- LeetCode
---

[LeetCode指路](https://leetcode.cn/problems/rotate-image/description/) 难度：中等

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

<!--more-->

#### 题解

`n == matrix.size() == matrix[i].size()`

| 1      | 2      | 3      | 4      | 5      |
|:------:|:------:|:------:|:------:|:------:|
| **6**  | **7**  | **8**  | **9**  | **10** |
| **11** | **12** | **13** | **14** | **15** |
| **16** | **17** | **18** | **19** | **20** |
| **21** | **22** | **23** | **24** | **25** |

纵 `x` 横 `y`

##### 方法1：使用辅助数组

（说实话，这真的不算使用另一个矩阵吗^o^）

通过观察可以发现，在旋转90度后，第一行的数字出现在了倒数第一列，第二行的数字出现在了倒数第二列......第n行的数字出现在了倒数第n列。

由此可得等式     **matrix[row][col] = matrix<sub>new</sub>[col][n-row-1]**

创建一个辅助数组（矩阵），按照上面的公式移动数字后，再将数值复制回原矩阵。

##### 方法2：原地旋转

建议画一个矩阵搭配使用

旋转90度，对于每一个数字是怎么样的呢？当我们以第一个数字开始研究旋转时，就会发现这个正方形矩阵的对称性。这个时候，我们会想到`算法日记-1 189.轮换数组`的内容。

将这个正方形矩阵一层层地剥开，分为多圈。不难看出，每一圈都形成了一个环，而将矩阵进行旋转，就相当于在这个环中进行轮换

剥出这些环很简单，只需要为每个环找一个起点就好了。我相信读者一定能想到最简单的起点，就是对角线上的起点了。这个想象起来很直观。至于在循环中如何表示起点，首先我们可以拆出`n/2`个环，这个`n/2`是个int类型。当`n`为偶数时，确实可以拆出这么多环，但是当`n`为奇数时，中间的环其实只有一个`1*1`的点，这算环吗？根本不用旋转的。我们现在得到了一个大循环：`for(int i = 0; i < n/2; i++)`

---

好了，现在我们落实到某一个环`i`的讨论上。上面讨论过了，这个环其实是一个轮换数组。不难发现，一轮会更新迭代4个元素，而总共有多少轮呢？

从数学上看：`m = 该环的总元素个数/4`

从旋转轮换看：`m = 边长-1`

可以说，将这个环切为元素容量为4的m个封闭的集合。而根据旋转对称来看，很明显，拆成四条长度相等的边，边长为正方形边长-1是再合适不过的。

所以有：`m = n-2*i-1`     这个`i` 表达了了每一个环的边长都是不一样的。

---

我们又进了一步，将一个环的问题缩小到了一条边上，我们只需要遍历这条边上的点，再根据情况进行处理就快要成功了。直觉告诉我们，这个旋转一定存在一个规律。

我们以`matrix[i][2]`为例，试着进行旋转。首先，这个位置是属于特例的直观和普遍抽象的折中，在不失普遍性的情况下给出的一个具体的例子（当然这个边长是要大于2的）。

最上面的一条边进行旋转90°，毫无疑问的，一定会落到右边的那条边上，也就是说，转换后的坐标一定落在`y = n-i-1`上。这是必然的，那么`x`的坐标就该2发力的。你自己画一张图，不难看出，这个代表数字2的这个边，原本是在左边，现在翻到上面去了。那么我们可以得到`x = j`，也就是说**matrix[ i ][ 2 ] = matrix<sub>new</sub>[ 2 ][ n-i-1 ]**

再稍微抽象一点 **matrix[row][col] = matrix<sub>new</sub>[col][n-row-1]** 这不是方法一的公式吗？

这样我们就解决了上面的那一条边，该轮到下一条边，右边了。

其实对于剩下的边，处理方法是完全一样的。我们可以说，经过这个公式的处理，`matrix[i][2]`已经旋转了90度，到达了它应该到达的地方。那么对于其他的点，在经过同样的处理后，也会旋转90度，这是一个函数啊！

接下来我给出代码

```cpp
//大循环，将矩阵拆为环
for(int i = 0; i < n/2; i++){
    int temp = matrix[i][i];
    int j = i;    //每个环的起点，对角线

    //边上的循环，边历每一条边
    for(int m = 0; m < n-2*i-1; m++,j++){
        //这四条指令是再环上的循环，也是在封闭集内的循环
        std::swap(temp,matrix[j][n-i-1]);
        std::swap(temp,matrix[n-i-1][n-j-1);
        std::swap(temp,matrix[n-j-1][i]);
        std::swap(temp,matrix[i][j]);
        //其实可以优化，不使用swap而是直接轮换赋值，但是swap更便于理解
    }
}
```

##### 方法3：用翻转代替旋转

在`算法日记-1 1`中使用了翻转来代替轮换。

在这题中，则用**主对角线翻转+水平翻转**得到了旋转的效果。

我们在数理上推理一下。

**matrix[ i ][ j ] ---主对角线翻转---> matrix[ j ][ i ]**

**matrix[ i ][ j ] ---水平翻转---> matrix[ i ][ n-j-1 ]**

组合得到：

**matrix[ i ][ j ] = matrix<sub>new</sub>[ j ][n-i-1]**

这不是我们方法1和方法2的公式吗，下次记得标明出处。
